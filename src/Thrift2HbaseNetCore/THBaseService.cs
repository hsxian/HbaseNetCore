/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using Thrift;
using Thrift.Collections;

using Thrift.Protocols;
using Thrift.Protocols.Entities;
using Thrift.Protocols.Utilities;
using Thrift.Transports;
using Thrift.Transports.Client;
using Thrift.Transports.Server;


public partial class THBaseService
{
  public interface IAsync
  {
    /// <summary>
    /// Test for the existence of columns in the table, as specified in the TGet.
    /// 
    /// @return true if the specified TGet matches one or more keys, false if not
    /// </summary>
    /// <param name="table">the table to check on</param>
    /// <param name="tget">the TGet to check for</param>
    Task<bool> existsAsync(byte[] table, TGet tget, CancellationToken cancellationToken);

    /// <summary>
    /// Method for getting data from a row.
    /// 
    /// If the row cannot be found an empty Result is returned.
    /// This can be checked by the empty field of the TResult
    /// 
    /// @return the result
    /// </summary>
    /// <param name="table">the table to get from</param>
    /// <param name="tget">the TGet to fetch</param>
    Task<TResult> @getAsync(byte[] table, TGet tget, CancellationToken cancellationToken);

    /// <summary>
    /// Method for getting multiple rows.
    /// 
    /// If a row cannot be found there will be a null
    /// value in the result list for that TGet at the
    /// same position.
    /// 
    /// So the Results are in the same order as the TGets.
    /// </summary>
    /// <param name="table">the table to get from</param>
    /// <param name="tgets">a list of TGets to fetch, the Result listwill have the Results at corresponding positionsor null if there was an error</param>
    Task<List<TResult>> getMultipleAsync(byte[] table, List<TGet> tgets, CancellationToken cancellationToken);

    /// <summary>
    /// Commit a TPut to a table.
    /// </summary>
    /// <param name="table">the table to put data in</param>
    /// <param name="tput">the TPut to put</param>
    Task putAsync(byte[] table, TPut tput, CancellationToken cancellationToken);

    /// <summary>
    /// Atomically checks if a row/family/qualifier value matches the expected
    /// value. If it does, it adds the TPut.
    /// 
    /// @return true if the new put was executed, false otherwise
    /// </summary>
    /// <param name="table">to check in and put to</param>
    /// <param name="row">row to check</param>
    /// <param name="family">column family to check</param>
    /// <param name="qualifier">column qualifier to check</param>
    /// <param name="value">the expected value, if not provided thecheck is for the non-existence of thecolumn in question</param>
    /// <param name="tput">the TPut to put if the check succeeds</param>
    Task<bool> checkAndPutAsync(byte[] table, byte[] row, byte[] family, byte[] qualifier, byte[] @value, TPut tput, CancellationToken cancellationToken);

    /// <summary>
    /// Commit a List of Puts to the table.
    /// </summary>
    /// <param name="table">the table to put data in</param>
    /// <param name="tputs">a list of TPuts to commit</param>
    Task putMultipleAsync(byte[] table, List<TPut> tputs, CancellationToken cancellationToken);

    /// <summary>
    /// Deletes as specified by the TDelete.
    /// 
    /// Note: "delete" is a reserved keyword and cannot be used in Thrift
    /// thus the inconsistent naming scheme from the other functions.
    /// </summary>
    /// <param name="table">the table to delete from</param>
    /// <param name="tdelete">the TDelete to delete</param>
    Task deleteSingleAsync(byte[] table, TDelete tdelete, CancellationToken cancellationToken);

    /// <summary>
    /// Bulk commit a List of TDeletes to the table.
    /// 
    /// Throws a TIOError if any of the deletes fail.
    /// 
    /// Always returns an empty list for backwards compatibility.
    /// </summary>
    /// <param name="table">the table to delete from</param>
    /// <param name="tdeletes">list of TDeletes to delete</param>
    Task<List<TDelete>> deleteMultipleAsync(byte[] table, List<TDelete> tdeletes, CancellationToken cancellationToken);

    /// <summary>
    /// Atomically checks if a row/family/qualifier value matches the expected
    /// value. If it does, it adds the delete.
    /// 
    /// @return true if the new delete was executed, false otherwise
    /// </summary>
    /// <param name="table">to check in and delete from</param>
    /// <param name="row">row to check</param>
    /// <param name="family">column family to check</param>
    /// <param name="qualifier">column qualifier to check</param>
    /// <param name="value">the expected value, if not provided thecheck is for the non-existence of thecolumn in question</param>
    /// <param name="tdelete">the TDelete to execute if the check succeeds</param>
    Task<bool> checkAndDeleteAsync(byte[] table, byte[] row, byte[] family, byte[] qualifier, byte[] @value, TDelete tdelete, CancellationToken cancellationToken);

    Task<TResult> incrementAsync(byte[] table, TIncrement tincrement, CancellationToken cancellationToken);

    Task<TResult> appendAsync(byte[] table, TAppend tappend, CancellationToken cancellationToken);

    /// <summary>
    /// Get a Scanner for the provided TScan object.
    /// 
    /// @return Scanner Id to be used with other scanner procedures
    /// </summary>
    /// <param name="table">the table to get the Scanner for</param>
    /// <param name="tscan">the scan object to get a Scanner for</param>
    Task<int> openScannerAsync(byte[] table, TScan tscan, CancellationToken cancellationToken);

    /// <summary>
    /// Grabs multiple rows from a Scanner.
    /// 
    /// @return Between zero and numRows TResults
    /// </summary>
    /// <param name="scannerId">the Id of the Scanner to return rows from. This is an Id returned from the openScanner function.</param>
    /// <param name="numRows">number of rows to return</param>
    Task<List<TResult>> getScannerRowsAsync(int scannerId, int numRows, CancellationToken cancellationToken);

    /// <summary>
    /// Closes the scanner. Should be called to free server side resources timely.
    /// Typically close once the scanner is not needed anymore, i.e. after looping
    /// over it to get all the required rows.
    /// </summary>
    /// <param name="scannerId">the Id of the Scanner to close *</param>
    Task closeScannerAsync(int scannerId, CancellationToken cancellationToken);

    /// <summary>
    /// mutateRow performs multiple mutations atomically on a single row.
    /// </summary>
    /// <param name="table">table to apply the mutations</param>
    /// <param name="trowMutations">mutations to apply</param>
    Task mutateRowAsync(byte[] table, TRowMutations trowMutations, CancellationToken cancellationToken);

    /// <summary>
    /// Get results for the provided TScan object.
    /// This helper function opens a scanner, get the results and close the scanner.
    /// 
    /// @return between zero and numRows TResults
    /// </summary>
    /// <param name="table">the table to get the Scanner for</param>
    /// <param name="tscan">the scan object to get a Scanner for</param>
    /// <param name="numRows">number of rows to return</param>
    Task<List<TResult>> getScannerResultsAsync(byte[] table, TScan tscan, int numRows, CancellationToken cancellationToken);

    /// <summary>
    /// Given a table and a row get the location of the region that
    /// would contain the given row key.
    /// 
    /// reload = true means the cache will be cleared and the location
    /// will be fetched from meta.
    /// </summary>
    /// <param name="table"></param>
    /// <param name="row"></param>
    /// <param name="reload"></param>
    Task<THRegionLocation> getRegionLocationAsync(byte[] table, byte[] row, bool reload, CancellationToken cancellationToken);

    /// <summary>
    /// Get all of the region locations for a given table.
    /// 
    /// </summary>
    /// <param name="table"></param>
    Task<List<THRegionLocation>> getAllRegionLocationsAsync(byte[] table, CancellationToken cancellationToken);

  }


  public class Client : TBaseClient, IDisposable, IAsync
  {
    public Client(TProtocol protocol) : this(protocol, protocol)
    {
    }

    public Client(TProtocol inputProtocol, TProtocol outputProtocol) : base(inputProtocol, outputProtocol)    {
    }
    public async Task<bool> existsAsync(byte[] table, TGet tget, CancellationToken cancellationToken)
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("exists", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new existsArgs();
      args.Table = table;
      args.Tget = tget;
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new existsResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.success)
      {
        return result.Success;
      }
      if (result.__isset.io)
      {
        throw result.Io;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "exists failed: unknown result");
    }

    public async Task<TResult> @getAsync(byte[] table, TGet tget, CancellationToken cancellationToken)
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("get", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new getArgs();
      args.Table = table;
      args.Tget = tget;
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new getResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.success)
      {
        return result.Success;
      }
      if (result.__isset.io)
      {
        throw result.Io;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "get failed: unknown result");
    }

    public async Task<List<TResult>> getMultipleAsync(byte[] table, List<TGet> tgets, CancellationToken cancellationToken)
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("getMultiple", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new getMultipleArgs();
      args.Table = table;
      args.Tgets = tgets;
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new getMultipleResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.success)
      {
        return result.Success;
      }
      if (result.__isset.io)
      {
        throw result.Io;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getMultiple failed: unknown result");
    }

    public async Task putAsync(byte[] table, TPut tput, CancellationToken cancellationToken)
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("put", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new putArgs();
      args.Table = table;
      args.Tput = tput;
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new putResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.io)
      {
        throw result.Io;
      }
      return;
    }

    public async Task<bool> checkAndPutAsync(byte[] table, byte[] row, byte[] family, byte[] qualifier, byte[] @value, TPut tput, CancellationToken cancellationToken)
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("checkAndPut", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new checkAndPutArgs();
      args.Table = table;
      args.Row = row;
      args.Family = family;
      args.Qualifier = qualifier;
      args.Value = @value;
      args.Tput = tput;
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new checkAndPutResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.success)
      {
        return result.Success;
      }
      if (result.__isset.io)
      {
        throw result.Io;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "checkAndPut failed: unknown result");
    }

    public async Task putMultipleAsync(byte[] table, List<TPut> tputs, CancellationToken cancellationToken)
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("putMultiple", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new putMultipleArgs();
      args.Table = table;
      args.Tputs = tputs;
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new putMultipleResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.io)
      {
        throw result.Io;
      }
      return;
    }

    public async Task deleteSingleAsync(byte[] table, TDelete tdelete, CancellationToken cancellationToken)
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("deleteSingle", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new deleteSingleArgs();
      args.Table = table;
      args.Tdelete = tdelete;
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new deleteSingleResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.io)
      {
        throw result.Io;
      }
      return;
    }

    public async Task<List<TDelete>> deleteMultipleAsync(byte[] table, List<TDelete> tdeletes, CancellationToken cancellationToken)
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("deleteMultiple", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new deleteMultipleArgs();
      args.Table = table;
      args.Tdeletes = tdeletes;
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new deleteMultipleResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.success)
      {
        return result.Success;
      }
      if (result.__isset.io)
      {
        throw result.Io;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "deleteMultiple failed: unknown result");
    }

    public async Task<bool> checkAndDeleteAsync(byte[] table, byte[] row, byte[] family, byte[] qualifier, byte[] @value, TDelete tdelete, CancellationToken cancellationToken)
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("checkAndDelete", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new checkAndDeleteArgs();
      args.Table = table;
      args.Row = row;
      args.Family = family;
      args.Qualifier = qualifier;
      args.Value = @value;
      args.Tdelete = tdelete;
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new checkAndDeleteResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.success)
      {
        return result.Success;
      }
      if (result.__isset.io)
      {
        throw result.Io;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "checkAndDelete failed: unknown result");
    }

    public async Task<TResult> incrementAsync(byte[] table, TIncrement tincrement, CancellationToken cancellationToken)
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("increment", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new incrementArgs();
      args.Table = table;
      args.Tincrement = tincrement;
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new incrementResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.success)
      {
        return result.Success;
      }
      if (result.__isset.io)
      {
        throw result.Io;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "increment failed: unknown result");
    }

    public async Task<TResult> appendAsync(byte[] table, TAppend tappend, CancellationToken cancellationToken)
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("append", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new appendArgs();
      args.Table = table;
      args.Tappend = tappend;
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new appendResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.success)
      {
        return result.Success;
      }
      if (result.__isset.io)
      {
        throw result.Io;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "append failed: unknown result");
    }

    public async Task<int> openScannerAsync(byte[] table, TScan tscan, CancellationToken cancellationToken)
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("openScanner", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new openScannerArgs();
      args.Table = table;
      args.Tscan = tscan;
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new openScannerResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.success)
      {
        return result.Success;
      }
      if (result.__isset.io)
      {
        throw result.Io;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "openScanner failed: unknown result");
    }

    public async Task<List<TResult>> getScannerRowsAsync(int scannerId, int numRows, CancellationToken cancellationToken)
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("getScannerRows", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new getScannerRowsArgs();
      args.ScannerId = scannerId;
      args.NumRows = numRows;
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new getScannerRowsResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.success)
      {
        return result.Success;
      }
      if (result.__isset.io)
      {
        throw result.Io;
      }
      if (result.__isset.ia)
      {
        throw result.Ia;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getScannerRows failed: unknown result");
    }

    public async Task closeScannerAsync(int scannerId, CancellationToken cancellationToken)
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("closeScanner", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new closeScannerArgs();
      args.ScannerId = scannerId;
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new closeScannerResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.io)
      {
        throw result.Io;
      }
      if (result.__isset.ia)
      {
        throw result.Ia;
      }
      return;
    }

    public async Task mutateRowAsync(byte[] table, TRowMutations trowMutations, CancellationToken cancellationToken)
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("mutateRow", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new mutateRowArgs();
      args.Table = table;
      args.TrowMutations = trowMutations;
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new mutateRowResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.io)
      {
        throw result.Io;
      }
      return;
    }

    public async Task<List<TResult>> getScannerResultsAsync(byte[] table, TScan tscan, int numRows, CancellationToken cancellationToken)
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("getScannerResults", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new getScannerResultsArgs();
      args.Table = table;
      args.Tscan = tscan;
      args.NumRows = numRows;
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new getScannerResultsResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.success)
      {
        return result.Success;
      }
      if (result.__isset.io)
      {
        throw result.Io;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getScannerResults failed: unknown result");
    }

    public async Task<THRegionLocation> getRegionLocationAsync(byte[] table, byte[] row, bool reload, CancellationToken cancellationToken)
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("getRegionLocation", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new getRegionLocationArgs();
      args.Table = table;
      args.Row = row;
      args.Reload = reload;
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new getRegionLocationResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.success)
      {
        return result.Success;
      }
      if (result.__isset.io)
      {
        throw result.Io;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getRegionLocation failed: unknown result");
    }

    public async Task<List<THRegionLocation>> getAllRegionLocationsAsync(byte[] table, CancellationToken cancellationToken)
    {
      await OutputProtocol.WriteMessageBeginAsync(new TMessage("getAllRegionLocations", TMessageType.Call, SeqId), cancellationToken);
      
      var args = new getAllRegionLocationsArgs();
      args.Table = table;
      
      await args.WriteAsync(OutputProtocol, cancellationToken);
      await OutputProtocol.WriteMessageEndAsync(cancellationToken);
      await OutputProtocol.Transport.FlushAsync(cancellationToken);
      
      var msg = await InputProtocol.ReadMessageBeginAsync(cancellationToken);
      if (msg.Type == TMessageType.Exception)
      {
        var x = await TApplicationException.ReadAsync(InputProtocol, cancellationToken);
        await InputProtocol.ReadMessageEndAsync(cancellationToken);
        throw x;
      }

      var result = new getAllRegionLocationsResult();
      await result.ReadAsync(InputProtocol, cancellationToken);
      await InputProtocol.ReadMessageEndAsync(cancellationToken);
      if (result.__isset.success)
      {
        return result.Success;
      }
      if (result.__isset.io)
      {
        throw result.Io;
      }
      throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getAllRegionLocations failed: unknown result");
    }

  }

  public class AsyncProcessor : ITAsyncProcessor
  {
    private IAsync _iAsync;

    public AsyncProcessor(IAsync iAsync)
    {
      if (iAsync == null) throw new ArgumentNullException(nameof(iAsync));

      _iAsync = iAsync;
      processMap_["exists"] = exists_ProcessAsync;
      processMap_["get"] = get_ProcessAsync;
      processMap_["getMultiple"] = getMultiple_ProcessAsync;
      processMap_["put"] = put_ProcessAsync;
      processMap_["checkAndPut"] = checkAndPut_ProcessAsync;
      processMap_["putMultiple"] = putMultiple_ProcessAsync;
      processMap_["deleteSingle"] = deleteSingle_ProcessAsync;
      processMap_["deleteMultiple"] = deleteMultiple_ProcessAsync;
      processMap_["checkAndDelete"] = checkAndDelete_ProcessAsync;
      processMap_["increment"] = increment_ProcessAsync;
      processMap_["append"] = append_ProcessAsync;
      processMap_["openScanner"] = openScanner_ProcessAsync;
      processMap_["getScannerRows"] = getScannerRows_ProcessAsync;
      processMap_["closeScanner"] = closeScanner_ProcessAsync;
      processMap_["mutateRow"] = mutateRow_ProcessAsync;
      processMap_["getScannerResults"] = getScannerResults_ProcessAsync;
      processMap_["getRegionLocation"] = getRegionLocation_ProcessAsync;
      processMap_["getAllRegionLocations"] = getAllRegionLocations_ProcessAsync;
    }

    protected delegate Task ProcessFunction(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken);
    protected Dictionary<string, ProcessFunction> processMap_ = new Dictionary<string, ProcessFunction>();

    public async Task<bool> ProcessAsync(TProtocol iprot, TProtocol oprot)
    {
      return await ProcessAsync(iprot, oprot, CancellationToken.None);
    }

    public async Task<bool> ProcessAsync(TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      try
      {
        var msg = await iprot.ReadMessageBeginAsync(cancellationToken);

        ProcessFunction fn;
        processMap_.TryGetValue(msg.Name, out fn);

        if (fn == null)
        {
          await TProtocolUtil.SkipAsync(iprot, TType.Struct, cancellationToken);
          await iprot.ReadMessageEndAsync(cancellationToken);
          var x = new TApplicationException (TApplicationException.ExceptionType.UnknownMethod, "Invalid method name: '" + msg.Name + "'");
          await oprot.WriteMessageBeginAsync(new TMessage(msg.Name, TMessageType.Exception, msg.SeqID), cancellationToken);
          await x.WriteAsync(oprot, cancellationToken);
          await oprot.WriteMessageEndAsync(cancellationToken);
          await oprot.Transport.FlushAsync(cancellationToken);
          return true;
        }

        await fn(msg.SeqID, iprot, oprot, cancellationToken);

      }
      catch (IOException)
      {
        return false;
      }

      return true;
    }

    public async Task exists_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new existsArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new existsResult();
      try
      {
        try
        {
          result.Success = await _iAsync.existsAsync(args.Table, args.Tget, cancellationToken);
        }
        catch (TIOError io)
        {
          result.Io = io;
        }
        await oprot.WriteMessageBeginAsync(new TMessage("exists", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("exists", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task get_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new getArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new getResult();
      try
      {
        try
        {
          result.Success = await _iAsync.@getAsync(args.Table, args.Tget, cancellationToken);
        }
        catch (TIOError io)
        {
          result.Io = io;
        }
        await oprot.WriteMessageBeginAsync(new TMessage("get", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("get", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task getMultiple_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new getMultipleArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new getMultipleResult();
      try
      {
        try
        {
          result.Success = await _iAsync.getMultipleAsync(args.Table, args.Tgets, cancellationToken);
        }
        catch (TIOError io)
        {
          result.Io = io;
        }
        await oprot.WriteMessageBeginAsync(new TMessage("getMultiple", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("getMultiple", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task put_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new putArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new putResult();
      try
      {
        try
        {
          await _iAsync.putAsync(args.Table, args.Tput, cancellationToken);
        }
        catch (TIOError io)
        {
          result.Io = io;
        }
        await oprot.WriteMessageBeginAsync(new TMessage("put", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("put", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task checkAndPut_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new checkAndPutArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new checkAndPutResult();
      try
      {
        try
        {
          result.Success = await _iAsync.checkAndPutAsync(args.Table, args.Row, args.Family, args.Qualifier, args.Value, args.Tput, cancellationToken);
        }
        catch (TIOError io)
        {
          result.Io = io;
        }
        await oprot.WriteMessageBeginAsync(new TMessage("checkAndPut", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("checkAndPut", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task putMultiple_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new putMultipleArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new putMultipleResult();
      try
      {
        try
        {
          await _iAsync.putMultipleAsync(args.Table, args.Tputs, cancellationToken);
        }
        catch (TIOError io)
        {
          result.Io = io;
        }
        await oprot.WriteMessageBeginAsync(new TMessage("putMultiple", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("putMultiple", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task deleteSingle_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new deleteSingleArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new deleteSingleResult();
      try
      {
        try
        {
          await _iAsync.deleteSingleAsync(args.Table, args.Tdelete, cancellationToken);
        }
        catch (TIOError io)
        {
          result.Io = io;
        }
        await oprot.WriteMessageBeginAsync(new TMessage("deleteSingle", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("deleteSingle", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task deleteMultiple_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new deleteMultipleArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new deleteMultipleResult();
      try
      {
        try
        {
          result.Success = await _iAsync.deleteMultipleAsync(args.Table, args.Tdeletes, cancellationToken);
        }
        catch (TIOError io)
        {
          result.Io = io;
        }
        await oprot.WriteMessageBeginAsync(new TMessage("deleteMultiple", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("deleteMultiple", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task checkAndDelete_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new checkAndDeleteArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new checkAndDeleteResult();
      try
      {
        try
        {
          result.Success = await _iAsync.checkAndDeleteAsync(args.Table, args.Row, args.Family, args.Qualifier, args.Value, args.Tdelete, cancellationToken);
        }
        catch (TIOError io)
        {
          result.Io = io;
        }
        await oprot.WriteMessageBeginAsync(new TMessage("checkAndDelete", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("checkAndDelete", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task increment_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new incrementArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new incrementResult();
      try
      {
        try
        {
          result.Success = await _iAsync.incrementAsync(args.Table, args.Tincrement, cancellationToken);
        }
        catch (TIOError io)
        {
          result.Io = io;
        }
        await oprot.WriteMessageBeginAsync(new TMessage("increment", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("increment", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task append_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new appendArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new appendResult();
      try
      {
        try
        {
          result.Success = await _iAsync.appendAsync(args.Table, args.Tappend, cancellationToken);
        }
        catch (TIOError io)
        {
          result.Io = io;
        }
        await oprot.WriteMessageBeginAsync(new TMessage("append", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("append", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task openScanner_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new openScannerArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new openScannerResult();
      try
      {
        try
        {
          result.Success = await _iAsync.openScannerAsync(args.Table, args.Tscan, cancellationToken);
        }
        catch (TIOError io)
        {
          result.Io = io;
        }
        await oprot.WriteMessageBeginAsync(new TMessage("openScanner", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("openScanner", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task getScannerRows_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new getScannerRowsArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new getScannerRowsResult();
      try
      {
        try
        {
          result.Success = await _iAsync.getScannerRowsAsync(args.ScannerId, args.NumRows, cancellationToken);
        }
        catch (TIOError io)
        {
          result.Io = io;
        }
        catch (TIllegalArgument ia)
        {
          result.Ia = ia;
        }
        await oprot.WriteMessageBeginAsync(new TMessage("getScannerRows", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("getScannerRows", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task closeScanner_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new closeScannerArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new closeScannerResult();
      try
      {
        try
        {
          await _iAsync.closeScannerAsync(args.ScannerId, cancellationToken);
        }
        catch (TIOError io)
        {
          result.Io = io;
        }
        catch (TIllegalArgument ia)
        {
          result.Ia = ia;
        }
        await oprot.WriteMessageBeginAsync(new TMessage("closeScanner", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("closeScanner", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task mutateRow_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new mutateRowArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new mutateRowResult();
      try
      {
        try
        {
          await _iAsync.mutateRowAsync(args.Table, args.TrowMutations, cancellationToken);
        }
        catch (TIOError io)
        {
          result.Io = io;
        }
        await oprot.WriteMessageBeginAsync(new TMessage("mutateRow", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("mutateRow", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task getScannerResults_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new getScannerResultsArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new getScannerResultsResult();
      try
      {
        try
        {
          result.Success = await _iAsync.getScannerResultsAsync(args.Table, args.Tscan, args.NumRows, cancellationToken);
        }
        catch (TIOError io)
        {
          result.Io = io;
        }
        await oprot.WriteMessageBeginAsync(new TMessage("getScannerResults", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("getScannerResults", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task getRegionLocation_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new getRegionLocationArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new getRegionLocationResult();
      try
      {
        try
        {
          result.Success = await _iAsync.getRegionLocationAsync(args.Table, args.Row, args.Reload, cancellationToken);
        }
        catch (TIOError io)
        {
          result.Io = io;
        }
        await oprot.WriteMessageBeginAsync(new TMessage("getRegionLocation", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("getRegionLocation", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

    public async Task getAllRegionLocations_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot, CancellationToken cancellationToken)
    {
      var args = new getAllRegionLocationsArgs();
      await args.ReadAsync(iprot, cancellationToken);
      await iprot.ReadMessageEndAsync(cancellationToken);
      var result = new getAllRegionLocationsResult();
      try
      {
        try
        {
          result.Success = await _iAsync.getAllRegionLocationsAsync(args.Table, cancellationToken);
        }
        catch (TIOError io)
        {
          result.Io = io;
        }
        await oprot.WriteMessageBeginAsync(new TMessage("getAllRegionLocations", TMessageType.Reply, seqid), cancellationToken); 
        await result.WriteAsync(oprot, cancellationToken);
      }
      catch (TTransportException)
      {
        throw;
      }
      catch (Exception ex)
      {
        Console.Error.WriteLine("Error occurred in processor:");
        Console.Error.WriteLine(ex.ToString());
        var x = new TApplicationException(TApplicationException.ExceptionType.InternalError," Internal error.");
        await oprot.WriteMessageBeginAsync(new TMessage("getAllRegionLocations", TMessageType.Exception, seqid), cancellationToken);
        await x.WriteAsync(oprot, cancellationToken);
      }
      await oprot.WriteMessageEndAsync(cancellationToken);
      await oprot.Transport.FlushAsync(cancellationToken);
    }

  }


  public partial class existsArgs : TBase
  {

    /// <summary>
    /// the table to check on
    /// </summary>
    public byte[] Table { get; set; }

    /// <summary>
    /// the TGet to check for
    /// </summary>
    public TGet Tget { get; set; }

    public existsArgs()
    {
    }

    public existsArgs(byte[] table, TGet tget) : this()
    {
      this.Table = table;
      this.Tget = tget;
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        bool isset_table = false;
        bool isset_tget = false;
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String)
              {
                Table = await iprot.ReadBinaryAsync(cancellationToken);
                isset_table = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 2:
              if (field.Type == TType.Struct)
              {
                Tget = new TGet();
                await Tget.ReadAsync(iprot, cancellationToken);
                isset_tget = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
        if (!isset_table)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_tget)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("exists_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();
        field.Name = "table";
        field.Type = TType.String;
        field.ID = 1;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteBinaryAsync(Table, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        field.Name = "tget";
        field.Type = TType.Struct;
        field.ID = 2;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await Tget.WriteAsync(oprot, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("exists_args(");
      sb.Append(", Table: ");
      sb.Append(Table);
      sb.Append(", Tget: ");
      sb.Append(Tget== null ? "<null>" : Tget.ToString());
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class existsResult : TBase
  {
    private bool _success;
    private TIOError _io;

    public bool Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }

    public TIOError Io
    {
      get
      {
        return _io;
      }
      set
      {
        __isset.io = true;
        this._io = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool success;
      public bool io;
    }

    public existsResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.Bool)
              {
                Success = await iprot.ReadBoolAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 1:
              if (field.Type == TType.Struct)
              {
                Io = new TIOError();
                await Io.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("exists_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.success)
        {
          field.Name = "Success";
          field.Type = TType.Bool;
          field.ID = 0;
          await oprot.WriteFieldBeginAsync(field, cancellationToken);
          await oprot.WriteBoolAsync(Success, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        else if(this.__isset.io)
        {
          if (Io != null)
          {
            field.Name = "Io";
            field.Type = TType.Struct;
            field.ID = 1;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Io.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("exists_result(");
      bool __first = true;
      if (__isset.success)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Success: ");
        sb.Append(Success);
      }
      if (Io != null && __isset.io)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Io: ");
        sb.Append(Io== null ? "<null>" : Io.ToString());
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getArgs : TBase
  {

    /// <summary>
    /// the table to get from
    /// </summary>
    public byte[] Table { get; set; }

    /// <summary>
    /// the TGet to fetch
    /// </summary>
    public TGet Tget { get; set; }

    public getArgs()
    {
    }

    public getArgs(byte[] table, TGet tget) : this()
    {
      this.Table = table;
      this.Tget = tget;
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        bool isset_table = false;
        bool isset_tget = false;
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String)
              {
                Table = await iprot.ReadBinaryAsync(cancellationToken);
                isset_table = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 2:
              if (field.Type == TType.Struct)
              {
                Tget = new TGet();
                await Tget.ReadAsync(iprot, cancellationToken);
                isset_tget = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
        if (!isset_table)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_tget)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("get_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();
        field.Name = "table";
        field.Type = TType.String;
        field.ID = 1;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteBinaryAsync(Table, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        field.Name = "tget";
        field.Type = TType.Struct;
        field.ID = 2;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await Tget.WriteAsync(oprot, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("get_args(");
      sb.Append(", Table: ");
      sb.Append(Table);
      sb.Append(", Tget: ");
      sb.Append(Tget== null ? "<null>" : Tget.ToString());
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getResult : TBase
  {
    private TResult _success;
    private TIOError _io;

    public TResult Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }

    public TIOError Io
    {
      get
      {
        return _io;
      }
      set
      {
        __isset.io = true;
        this._io = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool success;
      public bool io;
    }

    public getResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.Struct)
              {
                Success = new TResult();
                await Success.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 1:
              if (field.Type == TType.Struct)
              {
                Io = new TIOError();
                await Io.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("get_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.success)
        {
          if (Success != null)
          {
            field.Name = "Success";
            field.Type = TType.Struct;
            field.ID = 0;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Success.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        else if(this.__isset.io)
        {
          if (Io != null)
          {
            field.Name = "Io";
            field.Type = TType.Struct;
            field.ID = 1;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Io.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("get_result(");
      bool __first = true;
      if (Success != null && __isset.success)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Success: ");
        sb.Append(Success== null ? "<null>" : Success.ToString());
      }
      if (Io != null && __isset.io)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Io: ");
        sb.Append(Io== null ? "<null>" : Io.ToString());
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getMultipleArgs : TBase
  {

    /// <summary>
    /// the table to get from
    /// </summary>
    public byte[] Table { get; set; }

    /// <summary>
    /// a list of TGets to fetch, the Result list
    /// will have the Results at corresponding positions
    /// or null if there was an error
    /// </summary>
    public List<TGet> Tgets { get; set; }

    public getMultipleArgs()
    {
    }

    public getMultipleArgs(byte[] table, List<TGet> tgets) : this()
    {
      this.Table = table;
      this.Tgets = tgets;
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        bool isset_table = false;
        bool isset_tgets = false;
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String)
              {
                Table = await iprot.ReadBinaryAsync(cancellationToken);
                isset_table = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 2:
              if (field.Type == TType.List)
              {
                {
                  Tgets = new List<TGet>();
                  TList _list66 = await iprot.ReadListBeginAsync(cancellationToken);
                  for(int _i67 = 0; _i67 < _list66.Count; ++_i67)
                  {
                    TGet _elem68;
                    _elem68 = new TGet();
                    await _elem68.ReadAsync(iprot, cancellationToken);
                    Tgets.Add(_elem68);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
                isset_tgets = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
        if (!isset_table)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_tgets)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getMultiple_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();
        field.Name = "table";
        field.Type = TType.String;
        field.ID = 1;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteBinaryAsync(Table, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        field.Name = "tgets";
        field.Type = TType.List;
        field.ID = 2;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        {
          await oprot.WriteListBeginAsync(new TList(TType.Struct, Tgets.Count), cancellationToken);
          foreach (TGet _iter69 in Tgets)
          {
            await _iter69.WriteAsync(oprot, cancellationToken);
          }
          await oprot.WriteListEndAsync(cancellationToken);
        }
        await oprot.WriteFieldEndAsync(cancellationToken);
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getMultiple_args(");
      sb.Append(", Table: ");
      sb.Append(Table);
      sb.Append(", Tgets: ");
      sb.Append(Tgets);
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getMultipleResult : TBase
  {
    private List<TResult> _success;
    private TIOError _io;

    public List<TResult> Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }

    public TIOError Io
    {
      get
      {
        return _io;
      }
      set
      {
        __isset.io = true;
        this._io = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool success;
      public bool io;
    }

    public getMultipleResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.List)
              {
                {
                  Success = new List<TResult>();
                  TList _list70 = await iprot.ReadListBeginAsync(cancellationToken);
                  for(int _i71 = 0; _i71 < _list70.Count; ++_i71)
                  {
                    TResult _elem72;
                    _elem72 = new TResult();
                    await _elem72.ReadAsync(iprot, cancellationToken);
                    Success.Add(_elem72);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 1:
              if (field.Type == TType.Struct)
              {
                Io = new TIOError();
                await Io.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getMultiple_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.success)
        {
          if (Success != null)
          {
            field.Name = "Success";
            field.Type = TType.List;
            field.ID = 0;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            {
              await oprot.WriteListBeginAsync(new TList(TType.Struct, Success.Count), cancellationToken);
              foreach (TResult _iter73 in Success)
              {
                await _iter73.WriteAsync(oprot, cancellationToken);
              }
              await oprot.WriteListEndAsync(cancellationToken);
            }
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        else if(this.__isset.io)
        {
          if (Io != null)
          {
            field.Name = "Io";
            field.Type = TType.Struct;
            field.ID = 1;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Io.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getMultiple_result(");
      bool __first = true;
      if (Success != null && __isset.success)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Success: ");
        sb.Append(Success);
      }
      if (Io != null && __isset.io)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Io: ");
        sb.Append(Io== null ? "<null>" : Io.ToString());
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class putArgs : TBase
  {

    /// <summary>
    /// the table to put data in
    /// </summary>
    public byte[] Table { get; set; }

    /// <summary>
    /// the TPut to put
    /// </summary>
    public TPut Tput { get; set; }

    public putArgs()
    {
    }

    public putArgs(byte[] table, TPut tput) : this()
    {
      this.Table = table;
      this.Tput = tput;
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        bool isset_table = false;
        bool isset_tput = false;
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String)
              {
                Table = await iprot.ReadBinaryAsync(cancellationToken);
                isset_table = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 2:
              if (field.Type == TType.Struct)
              {
                Tput = new TPut();
                await Tput.ReadAsync(iprot, cancellationToken);
                isset_tput = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
        if (!isset_table)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_tput)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("put_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();
        field.Name = "table";
        field.Type = TType.String;
        field.ID = 1;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteBinaryAsync(Table, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        field.Name = "tput";
        field.Type = TType.Struct;
        field.ID = 2;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await Tput.WriteAsync(oprot, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("put_args(");
      sb.Append(", Table: ");
      sb.Append(Table);
      sb.Append(", Tput: ");
      sb.Append(Tput== null ? "<null>" : Tput.ToString());
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class putResult : TBase
  {
    private TIOError _io;

    public TIOError Io
    {
      get
      {
        return _io;
      }
      set
      {
        __isset.io = true;
        this._io = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool io;
    }

    public putResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.Struct)
              {
                Io = new TIOError();
                await Io.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("put_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.io)
        {
          if (Io != null)
          {
            field.Name = "Io";
            field.Type = TType.Struct;
            field.ID = 1;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Io.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("put_result(");
      bool __first = true;
      if (Io != null && __isset.io)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Io: ");
        sb.Append(Io== null ? "<null>" : Io.ToString());
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class checkAndPutArgs : TBase
  {
    private byte[] _value;

    /// <summary>
    /// to check in and put to
    /// </summary>
    public byte[] Table { get; set; }

    /// <summary>
    /// row to check
    /// </summary>
    public byte[] Row { get; set; }

    /// <summary>
    /// column family to check
    /// </summary>
    public byte[] Family { get; set; }

    /// <summary>
    /// column qualifier to check
    /// </summary>
    public byte[] Qualifier { get; set; }

    /// <summary>
    /// the expected value, if not provided the
    /// check is for the non-existence of the
    /// column in question
    /// </summary>
    public byte[] Value
    {
      get
      {
        return _value;
      }
      set
      {
        __isset.@value = true;
        this._value = value;
      }
    }

    /// <summary>
    /// the TPut to put if the check succeeds
    /// </summary>
    public TPut Tput { get; set; }


    public Isset __isset;
    public struct Isset
    {
      public bool @value;
    }

    public checkAndPutArgs()
    {
    }

    public checkAndPutArgs(byte[] table, byte[] row, byte[] family, byte[] qualifier, TPut tput) : this()
    {
      this.Table = table;
      this.Row = row;
      this.Family = family;
      this.Qualifier = qualifier;
      this.Tput = tput;
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        bool isset_table = false;
        bool isset_row = false;
        bool isset_family = false;
        bool isset_qualifier = false;
        bool isset_tput = false;
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String)
              {
                Table = await iprot.ReadBinaryAsync(cancellationToken);
                isset_table = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 2:
              if (field.Type == TType.String)
              {
                Row = await iprot.ReadBinaryAsync(cancellationToken);
                isset_row = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 3:
              if (field.Type == TType.String)
              {
                Family = await iprot.ReadBinaryAsync(cancellationToken);
                isset_family = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 4:
              if (field.Type == TType.String)
              {
                Qualifier = await iprot.ReadBinaryAsync(cancellationToken);
                isset_qualifier = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 5:
              if (field.Type == TType.String)
              {
                Value = await iprot.ReadBinaryAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 6:
              if (field.Type == TType.Struct)
              {
                Tput = new TPut();
                await Tput.ReadAsync(iprot, cancellationToken);
                isset_tput = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
        if (!isset_table)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_row)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_family)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_qualifier)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_tput)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("checkAndPut_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();
        field.Name = "table";
        field.Type = TType.String;
        field.ID = 1;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteBinaryAsync(Table, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        field.Name = "row";
        field.Type = TType.String;
        field.ID = 2;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteBinaryAsync(Row, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        field.Name = "family";
        field.Type = TType.String;
        field.ID = 3;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteBinaryAsync(Family, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        field.Name = "qualifier";
        field.Type = TType.String;
        field.ID = 4;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteBinaryAsync(Qualifier, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        if (Value != null && __isset.@value)
        {
          field.Name = "value";
          field.Type = TType.String;
          field.ID = 5;
          await oprot.WriteFieldBeginAsync(field, cancellationToken);
          await oprot.WriteBinaryAsync(Value, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        field.Name = "tput";
        field.Type = TType.Struct;
        field.ID = 6;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await Tput.WriteAsync(oprot, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("checkAndPut_args(");
      sb.Append(", Table: ");
      sb.Append(Table);
      sb.Append(", Row: ");
      sb.Append(Row);
      sb.Append(", Family: ");
      sb.Append(Family);
      sb.Append(", Qualifier: ");
      sb.Append(Qualifier);
      if (Value != null && __isset.@value)
      {
        sb.Append(", Value: ");
        sb.Append(Value);
      }
      sb.Append(", Tput: ");
      sb.Append(Tput== null ? "<null>" : Tput.ToString());
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class checkAndPutResult : TBase
  {
    private bool _success;
    private TIOError _io;

    public bool Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }

    public TIOError Io
    {
      get
      {
        return _io;
      }
      set
      {
        __isset.io = true;
        this._io = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool success;
      public bool io;
    }

    public checkAndPutResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.Bool)
              {
                Success = await iprot.ReadBoolAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 1:
              if (field.Type == TType.Struct)
              {
                Io = new TIOError();
                await Io.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("checkAndPut_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.success)
        {
          field.Name = "Success";
          field.Type = TType.Bool;
          field.ID = 0;
          await oprot.WriteFieldBeginAsync(field, cancellationToken);
          await oprot.WriteBoolAsync(Success, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        else if(this.__isset.io)
        {
          if (Io != null)
          {
            field.Name = "Io";
            field.Type = TType.Struct;
            field.ID = 1;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Io.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("checkAndPut_result(");
      bool __first = true;
      if (__isset.success)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Success: ");
        sb.Append(Success);
      }
      if (Io != null && __isset.io)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Io: ");
        sb.Append(Io== null ? "<null>" : Io.ToString());
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class putMultipleArgs : TBase
  {

    /// <summary>
    /// the table to put data in
    /// </summary>
    public byte[] Table { get; set; }

    /// <summary>
    /// a list of TPuts to commit
    /// </summary>
    public List<TPut> Tputs { get; set; }

    public putMultipleArgs()
    {
    }

    public putMultipleArgs(byte[] table, List<TPut> tputs) : this()
    {
      this.Table = table;
      this.Tputs = tputs;
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        bool isset_table = false;
        bool isset_tputs = false;
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String)
              {
                Table = await iprot.ReadBinaryAsync(cancellationToken);
                isset_table = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 2:
              if (field.Type == TType.List)
              {
                {
                  Tputs = new List<TPut>();
                  TList _list74 = await iprot.ReadListBeginAsync(cancellationToken);
                  for(int _i75 = 0; _i75 < _list74.Count; ++_i75)
                  {
                    TPut _elem76;
                    _elem76 = new TPut();
                    await _elem76.ReadAsync(iprot, cancellationToken);
                    Tputs.Add(_elem76);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
                isset_tputs = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
        if (!isset_table)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_tputs)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("putMultiple_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();
        field.Name = "table";
        field.Type = TType.String;
        field.ID = 1;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteBinaryAsync(Table, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        field.Name = "tputs";
        field.Type = TType.List;
        field.ID = 2;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        {
          await oprot.WriteListBeginAsync(new TList(TType.Struct, Tputs.Count), cancellationToken);
          foreach (TPut _iter77 in Tputs)
          {
            await _iter77.WriteAsync(oprot, cancellationToken);
          }
          await oprot.WriteListEndAsync(cancellationToken);
        }
        await oprot.WriteFieldEndAsync(cancellationToken);
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("putMultiple_args(");
      sb.Append(", Table: ");
      sb.Append(Table);
      sb.Append(", Tputs: ");
      sb.Append(Tputs);
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class putMultipleResult : TBase
  {
    private TIOError _io;

    public TIOError Io
    {
      get
      {
        return _io;
      }
      set
      {
        __isset.io = true;
        this._io = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool io;
    }

    public putMultipleResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.Struct)
              {
                Io = new TIOError();
                await Io.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("putMultiple_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.io)
        {
          if (Io != null)
          {
            field.Name = "Io";
            field.Type = TType.Struct;
            field.ID = 1;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Io.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("putMultiple_result(");
      bool __first = true;
      if (Io != null && __isset.io)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Io: ");
        sb.Append(Io== null ? "<null>" : Io.ToString());
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class deleteSingleArgs : TBase
  {

    /// <summary>
    /// the table to delete from
    /// </summary>
    public byte[] Table { get; set; }

    /// <summary>
    /// the TDelete to delete
    /// </summary>
    public TDelete Tdelete { get; set; }

    public deleteSingleArgs()
    {
    }

    public deleteSingleArgs(byte[] table, TDelete tdelete) : this()
    {
      this.Table = table;
      this.Tdelete = tdelete;
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        bool isset_table = false;
        bool isset_tdelete = false;
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String)
              {
                Table = await iprot.ReadBinaryAsync(cancellationToken);
                isset_table = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 2:
              if (field.Type == TType.Struct)
              {
                Tdelete = new TDelete();
                await Tdelete.ReadAsync(iprot, cancellationToken);
                isset_tdelete = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
        if (!isset_table)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_tdelete)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("deleteSingle_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();
        field.Name = "table";
        field.Type = TType.String;
        field.ID = 1;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteBinaryAsync(Table, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        field.Name = "tdelete";
        field.Type = TType.Struct;
        field.ID = 2;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await Tdelete.WriteAsync(oprot, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("deleteSingle_args(");
      sb.Append(", Table: ");
      sb.Append(Table);
      sb.Append(", Tdelete: ");
      sb.Append(Tdelete== null ? "<null>" : Tdelete.ToString());
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class deleteSingleResult : TBase
  {
    private TIOError _io;

    public TIOError Io
    {
      get
      {
        return _io;
      }
      set
      {
        __isset.io = true;
        this._io = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool io;
    }

    public deleteSingleResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.Struct)
              {
                Io = new TIOError();
                await Io.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("deleteSingle_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.io)
        {
          if (Io != null)
          {
            field.Name = "Io";
            field.Type = TType.Struct;
            field.ID = 1;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Io.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("deleteSingle_result(");
      bool __first = true;
      if (Io != null && __isset.io)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Io: ");
        sb.Append(Io== null ? "<null>" : Io.ToString());
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class deleteMultipleArgs : TBase
  {

    /// <summary>
    /// the table to delete from
    /// </summary>
    public byte[] Table { get; set; }

    /// <summary>
    /// list of TDeletes to delete
    /// </summary>
    public List<TDelete> Tdeletes { get; set; }

    public deleteMultipleArgs()
    {
    }

    public deleteMultipleArgs(byte[] table, List<TDelete> tdeletes) : this()
    {
      this.Table = table;
      this.Tdeletes = tdeletes;
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        bool isset_table = false;
        bool isset_tdeletes = false;
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String)
              {
                Table = await iprot.ReadBinaryAsync(cancellationToken);
                isset_table = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 2:
              if (field.Type == TType.List)
              {
                {
                  Tdeletes = new List<TDelete>();
                  TList _list78 = await iprot.ReadListBeginAsync(cancellationToken);
                  for(int _i79 = 0; _i79 < _list78.Count; ++_i79)
                  {
                    TDelete _elem80;
                    _elem80 = new TDelete();
                    await _elem80.ReadAsync(iprot, cancellationToken);
                    Tdeletes.Add(_elem80);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
                isset_tdeletes = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
        if (!isset_table)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_tdeletes)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("deleteMultiple_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();
        field.Name = "table";
        field.Type = TType.String;
        field.ID = 1;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteBinaryAsync(Table, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        field.Name = "tdeletes";
        field.Type = TType.List;
        field.ID = 2;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        {
          await oprot.WriteListBeginAsync(new TList(TType.Struct, Tdeletes.Count), cancellationToken);
          foreach (TDelete _iter81 in Tdeletes)
          {
            await _iter81.WriteAsync(oprot, cancellationToken);
          }
          await oprot.WriteListEndAsync(cancellationToken);
        }
        await oprot.WriteFieldEndAsync(cancellationToken);
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("deleteMultiple_args(");
      sb.Append(", Table: ");
      sb.Append(Table);
      sb.Append(", Tdeletes: ");
      sb.Append(Tdeletes);
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class deleteMultipleResult : TBase
  {
    private List<TDelete> _success;
    private TIOError _io;

    public List<TDelete> Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }

    public TIOError Io
    {
      get
      {
        return _io;
      }
      set
      {
        __isset.io = true;
        this._io = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool success;
      public bool io;
    }

    public deleteMultipleResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.List)
              {
                {
                  Success = new List<TDelete>();
                  TList _list82 = await iprot.ReadListBeginAsync(cancellationToken);
                  for(int _i83 = 0; _i83 < _list82.Count; ++_i83)
                  {
                    TDelete _elem84;
                    _elem84 = new TDelete();
                    await _elem84.ReadAsync(iprot, cancellationToken);
                    Success.Add(_elem84);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 1:
              if (field.Type == TType.Struct)
              {
                Io = new TIOError();
                await Io.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("deleteMultiple_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.success)
        {
          if (Success != null)
          {
            field.Name = "Success";
            field.Type = TType.List;
            field.ID = 0;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            {
              await oprot.WriteListBeginAsync(new TList(TType.Struct, Success.Count), cancellationToken);
              foreach (TDelete _iter85 in Success)
              {
                await _iter85.WriteAsync(oprot, cancellationToken);
              }
              await oprot.WriteListEndAsync(cancellationToken);
            }
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        else if(this.__isset.io)
        {
          if (Io != null)
          {
            field.Name = "Io";
            field.Type = TType.Struct;
            field.ID = 1;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Io.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("deleteMultiple_result(");
      bool __first = true;
      if (Success != null && __isset.success)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Success: ");
        sb.Append(Success);
      }
      if (Io != null && __isset.io)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Io: ");
        sb.Append(Io== null ? "<null>" : Io.ToString());
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class checkAndDeleteArgs : TBase
  {
    private byte[] _value;

    /// <summary>
    /// to check in and delete from
    /// </summary>
    public byte[] Table { get; set; }

    /// <summary>
    /// row to check
    /// </summary>
    public byte[] Row { get; set; }

    /// <summary>
    /// column family to check
    /// </summary>
    public byte[] Family { get; set; }

    /// <summary>
    /// column qualifier to check
    /// </summary>
    public byte[] Qualifier { get; set; }

    /// <summary>
    /// the expected value, if not provided the
    /// check is for the non-existence of the
    /// column in question
    /// </summary>
    public byte[] Value
    {
      get
      {
        return _value;
      }
      set
      {
        __isset.@value = true;
        this._value = value;
      }
    }

    /// <summary>
    /// the TDelete to execute if the check succeeds
    /// </summary>
    public TDelete Tdelete { get; set; }


    public Isset __isset;
    public struct Isset
    {
      public bool @value;
    }

    public checkAndDeleteArgs()
    {
    }

    public checkAndDeleteArgs(byte[] table, byte[] row, byte[] family, byte[] qualifier, TDelete tdelete) : this()
    {
      this.Table = table;
      this.Row = row;
      this.Family = family;
      this.Qualifier = qualifier;
      this.Tdelete = tdelete;
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        bool isset_table = false;
        bool isset_row = false;
        bool isset_family = false;
        bool isset_qualifier = false;
        bool isset_tdelete = false;
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String)
              {
                Table = await iprot.ReadBinaryAsync(cancellationToken);
                isset_table = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 2:
              if (field.Type == TType.String)
              {
                Row = await iprot.ReadBinaryAsync(cancellationToken);
                isset_row = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 3:
              if (field.Type == TType.String)
              {
                Family = await iprot.ReadBinaryAsync(cancellationToken);
                isset_family = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 4:
              if (field.Type == TType.String)
              {
                Qualifier = await iprot.ReadBinaryAsync(cancellationToken);
                isset_qualifier = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 5:
              if (field.Type == TType.String)
              {
                Value = await iprot.ReadBinaryAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 6:
              if (field.Type == TType.Struct)
              {
                Tdelete = new TDelete();
                await Tdelete.ReadAsync(iprot, cancellationToken);
                isset_tdelete = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
        if (!isset_table)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_row)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_family)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_qualifier)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_tdelete)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("checkAndDelete_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();
        field.Name = "table";
        field.Type = TType.String;
        field.ID = 1;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteBinaryAsync(Table, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        field.Name = "row";
        field.Type = TType.String;
        field.ID = 2;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteBinaryAsync(Row, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        field.Name = "family";
        field.Type = TType.String;
        field.ID = 3;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteBinaryAsync(Family, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        field.Name = "qualifier";
        field.Type = TType.String;
        field.ID = 4;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteBinaryAsync(Qualifier, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        if (Value != null && __isset.@value)
        {
          field.Name = "value";
          field.Type = TType.String;
          field.ID = 5;
          await oprot.WriteFieldBeginAsync(field, cancellationToken);
          await oprot.WriteBinaryAsync(Value, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        field.Name = "tdelete";
        field.Type = TType.Struct;
        field.ID = 6;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await Tdelete.WriteAsync(oprot, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("checkAndDelete_args(");
      sb.Append(", Table: ");
      sb.Append(Table);
      sb.Append(", Row: ");
      sb.Append(Row);
      sb.Append(", Family: ");
      sb.Append(Family);
      sb.Append(", Qualifier: ");
      sb.Append(Qualifier);
      if (Value != null && __isset.@value)
      {
        sb.Append(", Value: ");
        sb.Append(Value);
      }
      sb.Append(", Tdelete: ");
      sb.Append(Tdelete== null ? "<null>" : Tdelete.ToString());
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class checkAndDeleteResult : TBase
  {
    private bool _success;
    private TIOError _io;

    public bool Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }

    public TIOError Io
    {
      get
      {
        return _io;
      }
      set
      {
        __isset.io = true;
        this._io = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool success;
      public bool io;
    }

    public checkAndDeleteResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.Bool)
              {
                Success = await iprot.ReadBoolAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 1:
              if (field.Type == TType.Struct)
              {
                Io = new TIOError();
                await Io.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("checkAndDelete_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.success)
        {
          field.Name = "Success";
          field.Type = TType.Bool;
          field.ID = 0;
          await oprot.WriteFieldBeginAsync(field, cancellationToken);
          await oprot.WriteBoolAsync(Success, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        else if(this.__isset.io)
        {
          if (Io != null)
          {
            field.Name = "Io";
            field.Type = TType.Struct;
            field.ID = 1;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Io.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("checkAndDelete_result(");
      bool __first = true;
      if (__isset.success)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Success: ");
        sb.Append(Success);
      }
      if (Io != null && __isset.io)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Io: ");
        sb.Append(Io== null ? "<null>" : Io.ToString());
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class incrementArgs : TBase
  {

    /// <summary>
    /// the table to increment the value on
    /// </summary>
    public byte[] Table { get; set; }

    /// <summary>
    /// the TIncrement to increment
    /// </summary>
    public TIncrement Tincrement { get; set; }

    public incrementArgs()
    {
    }

    public incrementArgs(byte[] table, TIncrement tincrement) : this()
    {
      this.Table = table;
      this.Tincrement = tincrement;
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        bool isset_table = false;
        bool isset_tincrement = false;
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String)
              {
                Table = await iprot.ReadBinaryAsync(cancellationToken);
                isset_table = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 2:
              if (field.Type == TType.Struct)
              {
                Tincrement = new TIncrement();
                await Tincrement.ReadAsync(iprot, cancellationToken);
                isset_tincrement = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
        if (!isset_table)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_tincrement)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("increment_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();
        field.Name = "table";
        field.Type = TType.String;
        field.ID = 1;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteBinaryAsync(Table, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        field.Name = "tincrement";
        field.Type = TType.Struct;
        field.ID = 2;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await Tincrement.WriteAsync(oprot, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("increment_args(");
      sb.Append(", Table: ");
      sb.Append(Table);
      sb.Append(", Tincrement: ");
      sb.Append(Tincrement== null ? "<null>" : Tincrement.ToString());
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class incrementResult : TBase
  {
    private TResult _success;
    private TIOError _io;

    public TResult Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }

    public TIOError Io
    {
      get
      {
        return _io;
      }
      set
      {
        __isset.io = true;
        this._io = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool success;
      public bool io;
    }

    public incrementResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.Struct)
              {
                Success = new TResult();
                await Success.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 1:
              if (field.Type == TType.Struct)
              {
                Io = new TIOError();
                await Io.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("increment_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.success)
        {
          if (Success != null)
          {
            field.Name = "Success";
            field.Type = TType.Struct;
            field.ID = 0;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Success.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        else if(this.__isset.io)
        {
          if (Io != null)
          {
            field.Name = "Io";
            field.Type = TType.Struct;
            field.ID = 1;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Io.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("increment_result(");
      bool __first = true;
      if (Success != null && __isset.success)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Success: ");
        sb.Append(Success== null ? "<null>" : Success.ToString());
      }
      if (Io != null && __isset.io)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Io: ");
        sb.Append(Io== null ? "<null>" : Io.ToString());
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class appendArgs : TBase
  {

    /// <summary>
    /// the table to append the value on
    /// </summary>
    public byte[] Table { get; set; }

    /// <summary>
    /// the TAppend to append
    /// </summary>
    public TAppend Tappend { get; set; }

    public appendArgs()
    {
    }

    public appendArgs(byte[] table, TAppend tappend) : this()
    {
      this.Table = table;
      this.Tappend = tappend;
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        bool isset_table = false;
        bool isset_tappend = false;
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String)
              {
                Table = await iprot.ReadBinaryAsync(cancellationToken);
                isset_table = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 2:
              if (field.Type == TType.Struct)
              {
                Tappend = new TAppend();
                await Tappend.ReadAsync(iprot, cancellationToken);
                isset_tappend = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
        if (!isset_table)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_tappend)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("append_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();
        field.Name = "table";
        field.Type = TType.String;
        field.ID = 1;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteBinaryAsync(Table, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        field.Name = "tappend";
        field.Type = TType.Struct;
        field.ID = 2;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await Tappend.WriteAsync(oprot, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("append_args(");
      sb.Append(", Table: ");
      sb.Append(Table);
      sb.Append(", Tappend: ");
      sb.Append(Tappend== null ? "<null>" : Tappend.ToString());
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class appendResult : TBase
  {
    private TResult _success;
    private TIOError _io;

    public TResult Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }

    public TIOError Io
    {
      get
      {
        return _io;
      }
      set
      {
        __isset.io = true;
        this._io = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool success;
      public bool io;
    }

    public appendResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.Struct)
              {
                Success = new TResult();
                await Success.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 1:
              if (field.Type == TType.Struct)
              {
                Io = new TIOError();
                await Io.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("append_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.success)
        {
          if (Success != null)
          {
            field.Name = "Success";
            field.Type = TType.Struct;
            field.ID = 0;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Success.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        else if(this.__isset.io)
        {
          if (Io != null)
          {
            field.Name = "Io";
            field.Type = TType.Struct;
            field.ID = 1;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Io.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("append_result(");
      bool __first = true;
      if (Success != null && __isset.success)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Success: ");
        sb.Append(Success== null ? "<null>" : Success.ToString());
      }
      if (Io != null && __isset.io)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Io: ");
        sb.Append(Io== null ? "<null>" : Io.ToString());
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class openScannerArgs : TBase
  {

    /// <summary>
    /// the table to get the Scanner for
    /// </summary>
    public byte[] Table { get; set; }

    /// <summary>
    /// the scan object to get a Scanner for
    /// </summary>
    public TScan Tscan { get; set; }

    public openScannerArgs()
    {
    }

    public openScannerArgs(byte[] table, TScan tscan) : this()
    {
      this.Table = table;
      this.Tscan = tscan;
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        bool isset_table = false;
        bool isset_tscan = false;
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String)
              {
                Table = await iprot.ReadBinaryAsync(cancellationToken);
                isset_table = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 2:
              if (field.Type == TType.Struct)
              {
                Tscan = new TScan();
                await Tscan.ReadAsync(iprot, cancellationToken);
                isset_tscan = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
        if (!isset_table)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_tscan)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("openScanner_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();
        field.Name = "table";
        field.Type = TType.String;
        field.ID = 1;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteBinaryAsync(Table, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        field.Name = "tscan";
        field.Type = TType.Struct;
        field.ID = 2;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await Tscan.WriteAsync(oprot, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("openScanner_args(");
      sb.Append(", Table: ");
      sb.Append(Table);
      sb.Append(", Tscan: ");
      sb.Append(Tscan== null ? "<null>" : Tscan.ToString());
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class openScannerResult : TBase
  {
    private int _success;
    private TIOError _io;

    public int Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }

    public TIOError Io
    {
      get
      {
        return _io;
      }
      set
      {
        __isset.io = true;
        this._io = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool success;
      public bool io;
    }

    public openScannerResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.I32)
              {
                Success = await iprot.ReadI32Async(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 1:
              if (field.Type == TType.Struct)
              {
                Io = new TIOError();
                await Io.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("openScanner_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.success)
        {
          field.Name = "Success";
          field.Type = TType.I32;
          field.ID = 0;
          await oprot.WriteFieldBeginAsync(field, cancellationToken);
          await oprot.WriteI32Async(Success, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        else if(this.__isset.io)
        {
          if (Io != null)
          {
            field.Name = "Io";
            field.Type = TType.Struct;
            field.ID = 1;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Io.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("openScanner_result(");
      bool __first = true;
      if (__isset.success)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Success: ");
        sb.Append(Success);
      }
      if (Io != null && __isset.io)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Io: ");
        sb.Append(Io== null ? "<null>" : Io.ToString());
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getScannerRowsArgs : TBase
  {
    private int _numRows;

    /// <summary>
    /// the Id of the Scanner to return rows from. This is an Id returned from the openScanner function.
    /// </summary>
    public int ScannerId { get; set; }

    /// <summary>
    /// number of rows to return
    /// </summary>
    public int NumRows
    {
      get
      {
        return _numRows;
      }
      set
      {
        __isset.numRows = true;
        this._numRows = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool numRows;
    }

    public getScannerRowsArgs()
    {
      this._numRows = 1;
      this.__isset.numRows = true;
    }

    public getScannerRowsArgs(int scannerId) : this()
    {
      this.ScannerId = scannerId;
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        bool isset_scannerId = false;
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.I32)
              {
                ScannerId = await iprot.ReadI32Async(cancellationToken);
                isset_scannerId = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 2:
              if (field.Type == TType.I32)
              {
                NumRows = await iprot.ReadI32Async(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
        if (!isset_scannerId)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getScannerRows_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();
        field.Name = "scannerId";
        field.Type = TType.I32;
        field.ID = 1;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteI32Async(ScannerId, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        if (__isset.numRows)
        {
          field.Name = "numRows";
          field.Type = TType.I32;
          field.ID = 2;
          await oprot.WriteFieldBeginAsync(field, cancellationToken);
          await oprot.WriteI32Async(NumRows, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getScannerRows_args(");
      sb.Append(", ScannerId: ");
      sb.Append(ScannerId);
      if (__isset.numRows)
      {
        sb.Append(", NumRows: ");
        sb.Append(NumRows);
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getScannerRowsResult : TBase
  {
    private List<TResult> _success;
    private TIOError _io;
    private TIllegalArgument _ia;

    public List<TResult> Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }

    public TIOError Io
    {
      get
      {
        return _io;
      }
      set
      {
        __isset.io = true;
        this._io = value;
      }
    }

    /// <summary>
    /// if the scannerId is invalid
    /// </summary>
    public TIllegalArgument Ia
    {
      get
      {
        return _ia;
      }
      set
      {
        __isset.ia = true;
        this._ia = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool success;
      public bool io;
      public bool ia;
    }

    public getScannerRowsResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.List)
              {
                {
                  Success = new List<TResult>();
                  TList _list86 = await iprot.ReadListBeginAsync(cancellationToken);
                  for(int _i87 = 0; _i87 < _list86.Count; ++_i87)
                  {
                    TResult _elem88;
                    _elem88 = new TResult();
                    await _elem88.ReadAsync(iprot, cancellationToken);
                    Success.Add(_elem88);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 1:
              if (field.Type == TType.Struct)
              {
                Io = new TIOError();
                await Io.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 2:
              if (field.Type == TType.Struct)
              {
                Ia = new TIllegalArgument();
                await Ia.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getScannerRows_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.success)
        {
          if (Success != null)
          {
            field.Name = "Success";
            field.Type = TType.List;
            field.ID = 0;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            {
              await oprot.WriteListBeginAsync(new TList(TType.Struct, Success.Count), cancellationToken);
              foreach (TResult _iter89 in Success)
              {
                await _iter89.WriteAsync(oprot, cancellationToken);
              }
              await oprot.WriteListEndAsync(cancellationToken);
            }
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        else if(this.__isset.io)
        {
          if (Io != null)
          {
            field.Name = "Io";
            field.Type = TType.Struct;
            field.ID = 1;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Io.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        else if(this.__isset.ia)
        {
          if (Ia != null)
          {
            field.Name = "Ia";
            field.Type = TType.Struct;
            field.ID = 2;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Ia.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getScannerRows_result(");
      bool __first = true;
      if (Success != null && __isset.success)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Success: ");
        sb.Append(Success);
      }
      if (Io != null && __isset.io)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Io: ");
        sb.Append(Io== null ? "<null>" : Io.ToString());
      }
      if (Ia != null && __isset.ia)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Ia: ");
        sb.Append(Ia== null ? "<null>" : Ia.ToString());
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class closeScannerArgs : TBase
  {

    /// <summary>
    /// the Id of the Scanner to close *
    /// </summary>
    public int ScannerId { get; set; }

    public closeScannerArgs()
    {
    }

    public closeScannerArgs(int scannerId) : this()
    {
      this.ScannerId = scannerId;
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        bool isset_scannerId = false;
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.I32)
              {
                ScannerId = await iprot.ReadI32Async(cancellationToken);
                isset_scannerId = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
        if (!isset_scannerId)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("closeScanner_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();
        field.Name = "scannerId";
        field.Type = TType.I32;
        field.ID = 1;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteI32Async(ScannerId, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("closeScanner_args(");
      sb.Append(", ScannerId: ");
      sb.Append(ScannerId);
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class closeScannerResult : TBase
  {
    private TIOError _io;
    private TIllegalArgument _ia;

    public TIOError Io
    {
      get
      {
        return _io;
      }
      set
      {
        __isset.io = true;
        this._io = value;
      }
    }

    /// <summary>
    /// if the scannerId is invalid
    /// </summary>
    public TIllegalArgument Ia
    {
      get
      {
        return _ia;
      }
      set
      {
        __isset.ia = true;
        this._ia = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool io;
      public bool ia;
    }

    public closeScannerResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.Struct)
              {
                Io = new TIOError();
                await Io.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 2:
              if (field.Type == TType.Struct)
              {
                Ia = new TIllegalArgument();
                await Ia.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("closeScanner_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.io)
        {
          if (Io != null)
          {
            field.Name = "Io";
            field.Type = TType.Struct;
            field.ID = 1;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Io.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        else if(this.__isset.ia)
        {
          if (Ia != null)
          {
            field.Name = "Ia";
            field.Type = TType.Struct;
            field.ID = 2;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Ia.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("closeScanner_result(");
      bool __first = true;
      if (Io != null && __isset.io)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Io: ");
        sb.Append(Io== null ? "<null>" : Io.ToString());
      }
      if (Ia != null && __isset.ia)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Ia: ");
        sb.Append(Ia== null ? "<null>" : Ia.ToString());
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class mutateRowArgs : TBase
  {

    /// <summary>
    /// table to apply the mutations
    /// </summary>
    public byte[] Table { get; set; }

    /// <summary>
    /// mutations to apply
    /// </summary>
    public TRowMutations TrowMutations { get; set; }

    public mutateRowArgs()
    {
    }

    public mutateRowArgs(byte[] table, TRowMutations trowMutations) : this()
    {
      this.Table = table;
      this.TrowMutations = trowMutations;
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        bool isset_table = false;
        bool isset_trowMutations = false;
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String)
              {
                Table = await iprot.ReadBinaryAsync(cancellationToken);
                isset_table = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 2:
              if (field.Type == TType.Struct)
              {
                TrowMutations = new TRowMutations();
                await TrowMutations.ReadAsync(iprot, cancellationToken);
                isset_trowMutations = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
        if (!isset_table)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_trowMutations)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("mutateRow_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();
        field.Name = "table";
        field.Type = TType.String;
        field.ID = 1;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteBinaryAsync(Table, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        field.Name = "trowMutations";
        field.Type = TType.Struct;
        field.ID = 2;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await TrowMutations.WriteAsync(oprot, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("mutateRow_args(");
      sb.Append(", Table: ");
      sb.Append(Table);
      sb.Append(", TrowMutations: ");
      sb.Append(TrowMutations== null ? "<null>" : TrowMutations.ToString());
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class mutateRowResult : TBase
  {
    private TIOError _io;

    public TIOError Io
    {
      get
      {
        return _io;
      }
      set
      {
        __isset.io = true;
        this._io = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool io;
    }

    public mutateRowResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.Struct)
              {
                Io = new TIOError();
                await Io.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("mutateRow_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.io)
        {
          if (Io != null)
          {
            field.Name = "Io";
            field.Type = TType.Struct;
            field.ID = 1;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Io.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("mutateRow_result(");
      bool __first = true;
      if (Io != null && __isset.io)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Io: ");
        sb.Append(Io== null ? "<null>" : Io.ToString());
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getScannerResultsArgs : TBase
  {
    private int _numRows;

    /// <summary>
    /// the table to get the Scanner for
    /// </summary>
    public byte[] Table { get; set; }

    /// <summary>
    /// the scan object to get a Scanner for
    /// </summary>
    public TScan Tscan { get; set; }

    /// <summary>
    /// number of rows to return
    /// </summary>
    public int NumRows
    {
      get
      {
        return _numRows;
      }
      set
      {
        __isset.numRows = true;
        this._numRows = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool numRows;
    }

    public getScannerResultsArgs()
    {
      this._numRows = 1;
      this.__isset.numRows = true;
    }

    public getScannerResultsArgs(byte[] table, TScan tscan) : this()
    {
      this.Table = table;
      this.Tscan = tscan;
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        bool isset_table = false;
        bool isset_tscan = false;
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String)
              {
                Table = await iprot.ReadBinaryAsync(cancellationToken);
                isset_table = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 2:
              if (field.Type == TType.Struct)
              {
                Tscan = new TScan();
                await Tscan.ReadAsync(iprot, cancellationToken);
                isset_tscan = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 3:
              if (field.Type == TType.I32)
              {
                NumRows = await iprot.ReadI32Async(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
        if (!isset_table)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_tscan)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getScannerResults_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();
        field.Name = "table";
        field.Type = TType.String;
        field.ID = 1;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteBinaryAsync(Table, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        field.Name = "tscan";
        field.Type = TType.Struct;
        field.ID = 2;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await Tscan.WriteAsync(oprot, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        if (__isset.numRows)
        {
          field.Name = "numRows";
          field.Type = TType.I32;
          field.ID = 3;
          await oprot.WriteFieldBeginAsync(field, cancellationToken);
          await oprot.WriteI32Async(NumRows, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getScannerResults_args(");
      sb.Append(", Table: ");
      sb.Append(Table);
      sb.Append(", Tscan: ");
      sb.Append(Tscan== null ? "<null>" : Tscan.ToString());
      if (__isset.numRows)
      {
        sb.Append(", NumRows: ");
        sb.Append(NumRows);
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getScannerResultsResult : TBase
  {
    private List<TResult> _success;
    private TIOError _io;

    public List<TResult> Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }

    public TIOError Io
    {
      get
      {
        return _io;
      }
      set
      {
        __isset.io = true;
        this._io = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool success;
      public bool io;
    }

    public getScannerResultsResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.List)
              {
                {
                  Success = new List<TResult>();
                  TList _list90 = await iprot.ReadListBeginAsync(cancellationToken);
                  for(int _i91 = 0; _i91 < _list90.Count; ++_i91)
                  {
                    TResult _elem92;
                    _elem92 = new TResult();
                    await _elem92.ReadAsync(iprot, cancellationToken);
                    Success.Add(_elem92);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 1:
              if (field.Type == TType.Struct)
              {
                Io = new TIOError();
                await Io.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getScannerResults_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.success)
        {
          if (Success != null)
          {
            field.Name = "Success";
            field.Type = TType.List;
            field.ID = 0;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            {
              await oprot.WriteListBeginAsync(new TList(TType.Struct, Success.Count), cancellationToken);
              foreach (TResult _iter93 in Success)
              {
                await _iter93.WriteAsync(oprot, cancellationToken);
              }
              await oprot.WriteListEndAsync(cancellationToken);
            }
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        else if(this.__isset.io)
        {
          if (Io != null)
          {
            field.Name = "Io";
            field.Type = TType.Struct;
            field.ID = 1;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Io.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getScannerResults_result(");
      bool __first = true;
      if (Success != null && __isset.success)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Success: ");
        sb.Append(Success);
      }
      if (Io != null && __isset.io)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Io: ");
        sb.Append(Io== null ? "<null>" : Io.ToString());
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getRegionLocationArgs : TBase
  {
    private bool _reload;

    public byte[] Table { get; set; }

    public byte[] Row { get; set; }

    public bool Reload
    {
      get
      {
        return _reload;
      }
      set
      {
        __isset.reload = true;
        this._reload = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool reload;
    }

    public getRegionLocationArgs()
    {
    }

    public getRegionLocationArgs(byte[] table, byte[] row) : this()
    {
      this.Table = table;
      this.Row = row;
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        bool isset_table = false;
        bool isset_row = false;
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String)
              {
                Table = await iprot.ReadBinaryAsync(cancellationToken);
                isset_table = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 2:
              if (field.Type == TType.String)
              {
                Row = await iprot.ReadBinaryAsync(cancellationToken);
                isset_row = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 3:
              if (field.Type == TType.Bool)
              {
                Reload = await iprot.ReadBoolAsync(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
        if (!isset_table)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_row)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getRegionLocation_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();
        field.Name = "table";
        field.Type = TType.String;
        field.ID = 1;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteBinaryAsync(Table, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        field.Name = "row";
        field.Type = TType.String;
        field.ID = 2;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteBinaryAsync(Row, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        if (__isset.reload)
        {
          field.Name = "reload";
          field.Type = TType.Bool;
          field.ID = 3;
          await oprot.WriteFieldBeginAsync(field, cancellationToken);
          await oprot.WriteBoolAsync(Reload, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getRegionLocation_args(");
      sb.Append(", Table: ");
      sb.Append(Table);
      sb.Append(", Row: ");
      sb.Append(Row);
      if (__isset.reload)
      {
        sb.Append(", Reload: ");
        sb.Append(Reload);
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getRegionLocationResult : TBase
  {
    private THRegionLocation _success;
    private TIOError _io;

    public THRegionLocation Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }

    public TIOError Io
    {
      get
      {
        return _io;
      }
      set
      {
        __isset.io = true;
        this._io = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool success;
      public bool io;
    }

    public getRegionLocationResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.Struct)
              {
                Success = new THRegionLocation();
                await Success.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 1:
              if (field.Type == TType.Struct)
              {
                Io = new TIOError();
                await Io.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getRegionLocation_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.success)
        {
          if (Success != null)
          {
            field.Name = "Success";
            field.Type = TType.Struct;
            field.ID = 0;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Success.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        else if(this.__isset.io)
        {
          if (Io != null)
          {
            field.Name = "Io";
            field.Type = TType.Struct;
            field.ID = 1;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Io.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getRegionLocation_result(");
      bool __first = true;
      if (Success != null && __isset.success)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Success: ");
        sb.Append(Success== null ? "<null>" : Success.ToString());
      }
      if (Io != null && __isset.io)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Io: ");
        sb.Append(Io== null ? "<null>" : Io.ToString());
      }
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getAllRegionLocationsArgs : TBase
  {

    public byte[] Table { get; set; }

    public getAllRegionLocationsArgs()
    {
    }

    public getAllRegionLocationsArgs(byte[] table) : this()
    {
      this.Table = table;
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        bool isset_table = false;
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.String)
              {
                Table = await iprot.ReadBinaryAsync(cancellationToken);
                isset_table = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
        if (!isset_table)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getAllRegionLocations_args");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();
        field.Name = "table";
        field.Type = TType.String;
        field.ID = 1;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteBinaryAsync(Table, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getAllRegionLocations_args(");
      sb.Append(", Table: ");
      sb.Append(Table);
      sb.Append(")");
      return sb.ToString();
    }
  }


  public partial class getAllRegionLocationsResult : TBase
  {
    private List<THRegionLocation> _success;
    private TIOError _io;

    public List<THRegionLocation> Success
    {
      get
      {
        return _success;
      }
      set
      {
        __isset.success = true;
        this._success = value;
      }
    }

    public TIOError Io
    {
      get
      {
        return _io;
      }
      set
      {
        __isset.io = true;
        this._io = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool success;
      public bool io;
    }

    public getAllRegionLocationsResult()
    {
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 0:
              if (field.Type == TType.List)
              {
                {
                  Success = new List<THRegionLocation>();
                  TList _list94 = await iprot.ReadListBeginAsync(cancellationToken);
                  for(int _i95 = 0; _i95 < _list94.Count; ++_i95)
                  {
                    THRegionLocation _elem96;
                    _elem96 = new THRegionLocation();
                    await _elem96.ReadAsync(iprot, cancellationToken);
                    Success.Add(_elem96);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 1:
              if (field.Type == TType.Struct)
              {
                Io = new TIOError();
                await Io.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("getAllRegionLocations_result");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();

        if(this.__isset.success)
        {
          if (Success != null)
          {
            field.Name = "Success";
            field.Type = TType.List;
            field.ID = 0;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            {
              await oprot.WriteListBeginAsync(new TList(TType.Struct, Success.Count), cancellationToken);
              foreach (THRegionLocation _iter97 in Success)
              {
                await _iter97.WriteAsync(oprot, cancellationToken);
              }
              await oprot.WriteListEndAsync(cancellationToken);
            }
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        else if(this.__isset.io)
        {
          if (Io != null)
          {
            field.Name = "Io";
            field.Type = TType.Struct;
            field.ID = 1;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await Io.WriteAsync(oprot, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
          }
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString()
    {
      var sb = new StringBuilder("getAllRegionLocations_result(");
      bool __first = true;
      if (Success != null && __isset.success)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Success: ");
        sb.Append(Success);
      }
      if (Io != null && __isset.io)
      {
        if(!__first) { sb.Append(", "); }
        __first = false;
        sb.Append("Io: ");
        sb.Append(Io== null ? "<null>" : Io.ToString());
      }
      sb.Append(")");
      return sb.ToString();
    }
  }

}
